public class Solution {
    public int findDuplicate(int[] nums) {
        if(nums.length > 1) {
            int slow = nums[0];
            int fast = nums[nums[0]];
            while(fast != slow) {
                slow = nums[slow];
                fast = nums[nums[fast]];
            }
            fast = 0;
            while(fast != slow) {
                slow = nums[slow];
                fast = nums[fast];
            }
            return slow;
        }
        return -1;
    }
}

/*
很难想到，使用linkedlist的中找cycle的思路。
将table中的元素当做指针来使用，快慢指针分别是nums[i]和nums[nums[i]]，
这样fast就是slow路程的两倍，
而我们可以证明循环cycle的entry点就是重复的那个number

When they meet, assume slow tag move s steps, fast tag move 2s steps, the circle length is c.
There must be:

2s = s + n*c

=> s = n*c....(1)

Then, assume the length from start point to entry point is x, and the length from the entry
point to the meet point is a.
There must be: s = x+a....(2)

So, from (1) and (2)

x+a = s = n*c

=> x+a = n*c

=> x+a = (n-1)*c+c

=> x = (n-1)*c+c-a

c-a means the length from the meetpoint to the entry point.

LHS means: the new tag from start point move x steps.

RHS means: the slow tag moves (n-1) cycles plus the length from the meetpoint to the entry point.

So, we can get the entry point when the new tag meet the slow tag.
*/